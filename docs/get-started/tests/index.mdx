---
sidebar_position: 4
description: Tests tell Doc Detective what actions to perform, how, and where.
---

import JsonYamlTabs from "@site/src/components/JsonYamlTabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Tests

{/* > Want help writing your test steps? Check out the [Action Builder prototype](/app). */}

Tests tell Doc Detective what actions to perform, how, and where. Tests are made of three sets of components:

- **Test specification**: The highest-level component, test specifications (or specs) are collection of tests that should run together. [Contexts](/docs/get-started/config/contexts) defined in the spec are shared by all tests in the spec. Test specifications are equivalent to test suites in other testing frameworks.
- **Test**: A test to run within a spec. Each test has a name, and a set of steps to perform. Tests are equivalent to test cases in other testing frameworks.
- **Steps**: A step is a single action to perform within a test. Each individual step acts as an assertion that the step completes as expected. Steps are roughly equivalent to assertions in other testing frameworks.

  Each step can perform an action, which is a command that tells Doc Detective what to do. Actions can have additional properties that further define the action.

  - [**checkLink**](/docs/get-started/actions/checkLink): Check if a URL returns an acceptable status code from a GET request.
  - [**click**](/docs/get-started/actions/click): Click or tap an element.
  - [**dragAndDrop**](/docs/get-started/actions/dragAndDrop): Drag an element and drop it on a target.
  - [**find**](/docs/get-started/actions/find): Check if an element exists with the specified selector.
  - [**goTo**](/docs/get-started/actions/goTo): Navigate to a specified URL.
  - [**httpRequest**](/docs/get-started/actions/httpRequest): Perform a generic HTTP request, for example to an API.
  - [**loadVariables**](/docs/get-started/actions/loadVariables): Load environment variables from a `.env` file.
  - [**saveCookie**](/docs/get-started/actions/saveCookie): Save a specific browser cookie to a file or environment variable for later reuse.
  - [**loadCookie**](/docs/get-started/actions/loadCookie): Load a specific cookie from a file or environment variable into the browser.
  - [**record**](/docs/get-started/actions/record) and [**stopRecord**](/docs/get-started/actions/stopRecord): Capture a video of test execution.
  - [**runCode**](/docs/get-started/actions/runCode): Assemble and run code.
  - [**runShell**](/docs/get-started/actions/runShell): Perform a native shell command.
  - [**screenshot**](/docs/get-started/actions/screenshot): Take a screenshot in PNG format.
  - [**type**](/docs/get-started/actions/type): Type keys. To type special keys, begin and end the string with `$` and use the special key’s enum. For example, to type the Escape key, enter `$ESCAPE$`.
  - [**wait**](/docs/get-started/actions/wait): Pause before performing the next action.

## Define a test

You can define test specs in multiple ways:

- [Standalone JSON files](#standalone-json-or-yaml) help you see the entirety of the spec and keep it in a separate, machine-readable format.
- [Inline JSON](#inline-json-or-yaml) allows you to define tests directly in your documentation source files.
- [Detected tests](#detected-tests) are automatically generated by Doc Detective based on your documentation source files and your configuration.

### Standalone JSON or YAML

Test specs in standalone JSON or YAML files use the following basic structure:

<JsonYamlTabs object={{
  specId: "spec-id",
  description: "Spec Description",
  tests: [
    {
      testId: "test-id",
      description: "Test Description",
      steps: [
        {
          stepId: "step-id",
          description: "Step description. This object also needs additional step properties like `find`, `goTo`, or `httpRequest`."
        }
      ]
    }
  ]
}}></JsonYamlTabs>

> For comprehensive options, see [`specification`](/docs/references/schemas/specification).

Here's an example test for performing a Google search and saving a screenshot of the results:

<JsonYamlTabs object={{
  tests: [
    {
      steps: [
        {
          goTo: "https://www.google.com"
        },
        {
          find: {
            selector: "[title=Search]",
            click: true
          }
        },
        {
          type: ["American Shorthair kittens", "$ENTER$"]
        },
        {
          wait: 5000
        },
        {
          screenshot: "search-results.png"
        }
      ]
    }
  ]
}}></JsonYamlTabs>

### Inline JSON or YAML

You can define tests directly in your documentation source files using inline JSON or YAML. Inline tests are useful for small, straightforward tests that you want to keep close to the content they test.

Inline tests are also excellent for maintaining tests because they are convenient to update and keep in sync with the content they test as the content changes.

> Inline tests depend on your [config](/docs/references/schemas/config)'s `fileType` definitions. This page uses the default Markdown configuration, but you should update your config to match your documentation source files.

Inline tests use specially formatted comments with JSON or YAML objects to declare the tests and steps. Doc Detective reads the input file, line by line, and extracts the tests and steps from the comments. You can declare multiple tests and steps in a single file, using your config's test start, test end, step, and ignore patterns.

> All test and step comments must be on a single line. Doc Detective doesn't support multi-line comments.

When you declare a test, you can specify any of the test properties available in the standalone JSON format, though `steps` is normally omitted. See [`test`](/docs/references/schemas/test).

If you declare a new test without closing the previous test, Doc Detective automatically closes the previous test before starting the new one.

When you declare a step, you can specify any of the properties of the action you want to perform. See [Actions](/docs/category/actions).

If you declare a step without declaring a test, Doc Detective automatically creates a test to contain the step.

#### Comment patterns by file type

Doc Detective supports different comment patterns depending on your file type:

**Markdown files** (`.md`, `.markdown`, `.mdx`):

- JSX-style comments: `{/* test { "testId": "my-test" } */}`
- HTML comments: `<!-- test { "testId": "my-test" } -->`
- Markdown link comments: `[comment]: # (test { "testId": "my-test" })`, `[comment]: # 'test { "testId": "my-test" }'`, or `[comment]: # "test { \"testId\": \"my-test\" }"`
- Step comments: `{/* step { "goTo": "https://example.com" } */}`
- Test end: `{/* test end */}` or `<!-- test end -->` or `[comment]: # (test end)`
- Ignore blocks: `{/* test ignore start */}` and `{/* test ignore end */}`

> When using Markdown link comments with double quotes, escape internal quotes with backslashes.

**HTML files** (`.html`, `.htm`):

- Test comments: `<!-- test { "testId": "my-test" } -->`
- Step comments: `<!-- step { "goTo": "https://example.com" } -->`
- Test end: `<!-- test end -->`
- Ignore blocks: `<!-- test ignore start -->` and `<!-- test ignore end -->`

**AsciiDoc files** (`.adoc`, `.asciidoc`, `.asc`):

- Line comments: `// (test { "testId": "my-test" })`
- Step comments: `// (step { "goTo": "https://example.com" })`
- Test end: `// (test end)`
- Ignore blocks: `// (test ignore start)` and `// (test ignore end)`

**DITA XML files** (`.dita`, `.ditamap`, `.xml`):

DITA (Darwin Information Typing Architecture) files use XML processing instructions to define tests. Processing instructions must start with `<?doc-detective` for Doc Detective to recognize them.

DITA supports multiple syntax options:

**JSON format:**
- Test comments: `<?doc-detective test {"testId": "my-test", "detectSteps": false} ?>`
- Step comments: `<?doc-detective step {"checkLink": "https://example.com"} ?>`
- Test end: `<?doc-detective test end?>`
- Ignore blocks: `<?doc-detective test ignore start?>` and `<?doc-detective test ignore end?>`

**YAML format:**
- Test comments:
  
  ```
  <?doc-detective test
    testId: my-test
    detectSteps: false
  ?>
  ```
- Step comments: `<?doc-detective step checkLink: "https://example.com" ?>`
- Test end: `<?doc-detective test end?>`
- Ignore blocks: `<?doc-detective test ignore start?>` and `<?doc-detective test ignore end?>`

**XML attribute format:**
- Test comments: `<?doc-detective test testId="my-test" detectSteps=false ?>`
- Step comments: `<?doc-detective step checkLink="https://example.com" ?>`
- Test end: `<?doc-detective test end?>`
- Ignore blocks: `<?doc-detective test ignore start?>` and `<?doc-detective test ignore end?>`

Attribute values are automatically converted to the appropriate type: booleans (`detectSteps=false`), numbers (`wait=500`), and strings. You can use dot notation for nested objects—for example, `<?doc-detective step httpRequest.url="https://api.example.com" httpRequest.method="GET" ?>` creates a nested `httpRequest` object with `url` and `method` properties.

You can also use HTML comment syntax as an alternative to processing instructions:

- Test comments: `<!-- test testId="my-test" detectSteps=false -->`
- Step comments: `<!-- step checkLink="https://example.com" -->`
- Test end: `<!-- test end -->`
- Ignore blocks: `<!-- test ignore start -->` and `<!-- test ignore end -->`

HTML comments and processing instructions work identically. You can use whichever fits your documentation workflow better, or mix them in the same file.

#### Examples

Here's an example using **JSON syntax** in Markdown:

```markdown
[comment]: # 'test {"testId": "kitten-search"}'

To search for American Shorthair kittens,

1. Go to [Google](https://www.google.com).

   [comment]: # 'step {"goTo": "https://www.google.com"}'

2. In the search bar, enter "American Shorthair kittens", then press Enter.

   [comment]: # 'step { "find": { "selector": "[title=Search]", "click": true } }'
   [comment]: # 'step { "type": ["American Shorthair kittens", "$ENTER$"] }'
   [comment]: # 'step { "wait": 5000 }'

![Search results](search-results.png)

[comment]: # 'step { "screenshot": "search-results.png" }'
[comment]: # "test end"
```

Here's the same example using **YAML syntax** in Markdown:

```markdown
{/_ test testId: kitten-search _/}

To search for American Shorthair kittens,

1. Go to [Google](https://www.google.com).

   {/_ step goTo: https://www.google.com _/}

2. In the search bar, enter "American Shorthair kittens", then press Enter.

   {/_ step find: selector: "[title=Search]" click: true _/} {/_ step type: - "American Shorthair kittens" - "$ENTER$" _/} {/_ step wait: 5000 _/}

![Search results](search-results.png)

{/_ step screenshot: search-results.png _/} {/_ test end _/}
```

**HTML example**:

```html
<!-- test { "testId": "navigation-test" } -->
<p>Navigate to our homepage:</p>
<!-- step { "goTo": "https://example.com" } -->

<p>Click the menu button:</p>
<!-- step { "click": "Menu" } -->

<!-- test end -->
```

**AsciiDoc example**:

```asciidoc
// (test { "testId": "doc-test" })
== Getting Started

Navigate to the application:
// (step { "goTo": "https://app.example.com" })

Click the *Start* button:
// (step { "click": "Start" })

// (test end)
```

### Detected tests

Doc Detective can automatically generate tests based on your documentation source files and your `fileTypes` configuration. Detected tests are useful for large, complex test suites that you want to keep in sync with your documentation. Test detection works by setting `detectSteps` to `true` and defining markup patterns and associated actions in the `fileTypes.markup` array in your [config](/docs/references/schemas/config), which Doc Detective uses to extract steps from your doc source files. You can define multiple test patterns in your config to extract different types of tests from your documentation.

Detected tests are useful for keeping your tests in sync with your documentation. When you update your documentation, Doc Detective automatically updates the tests based on the new content. Detected tests are generated automatically. You can't edit detected tests directly, but you can update your config or documentation source files to change the tests.

> You can mix detected tests with [inline tests](#inline-json-or-yaml) to declare steps that might not be covered in your content, such starting or stopping a recording.

Doc Detective includes default markup patterns for Markdown and DITA files. Here are the built-in patterns:

#### Markdown patterns

````json
{
  "fileTypes": [
    {
      "name": "markdown",
      "extensions": ["md", "markdown", "mdx"],
      "markup": [
        {
          "name": "checkHyperlink",
          "regex": [
            "(?<!\\!)\\[[^\\]]+\\]\\(\\s*(https?:\\/\\/[^\\s)]+)(?:\\s+\"[^\"]*\")?\\s*\\)"
          ],
          "actions": ["checkLink"]
        },
        {
          "name": "clickOnscreenText",
          "regex": [
            "\\b(?:[Cc]lick|[Tt]ap|[Ll]eft-click|[Cc]hoose|[Ss]elect|[Cc]heck)\\b\\s+\\*\\*((?:(?!\\*\\*).)+)\\*\\*"
          ],
          "actions": ["click"]
        },
        {
          "name": "findOnscreenText",
          "regex": ["\\*\\*((?:(?!\\*\\*).)+)\\*\\*"],
          "actions": ["find"]
        },
        {
          "name": "goToUrl",
          "regex": [
            "\\b(?:[Gg]o\\s+to|[Oo]pen|[Nn]avigate\\s+to|[Vv]isit|[Aa]ccess|[Pp]roceed\\s+to|[Ll]aunch)\\b\\s+\\[[^\\]]+\\]\\(\\s*(https?:\\/\\/[^\\s)]+)(?:\\s+\"[^\"]*\")?\\s*\\)"
          ],
          "actions": ["goTo"]
        },
        {
          "name": "screenshotImage",
          "regex": [
            "!\\[[^\\]]*\\]\\(\\s*([^\\s)]+)(?:\\s+\"[^\"]*\")?\\s*\\)\\s*\\{(?=[^}]*\\.screenshot)[^}]*\\}"
          ],
          "actions": ["screenshot"]
        },
        {
          "name": "typeText",
          "regex": ["\\b(?:press|enter|type)\\b\\s+\"([^\"]+)\""],
          "actions": ["type"]
        },
        {
          "name": "httpRequestFormat",
          "regex": [
            "```(?:http)?\\r?\\n([A-Z]+)\\s+([^\\s]+)(?:\\s+HTTP\\/[\\d.]+)?\\r?\\n((?:[^\\s]+:\\s+[^\\s]+\\r?\\n)*)?(?:\\s+([\\s\\S]*?)\\r?\\n+)?```"
          ],
          "actions": [
            {
              "httpRequest": {
                "method": "$1",
                "url": "$2",
                "request": {
                  "headers": "$3",
                  "body": "$4"
                }
              }
            }
          ]
        },
        {
          "name": "runCode",
          "regex": [
            "```(bash|python|py|javascript|js)(?![^\\r\\n]*testIgnore)[^\\r\\n]*\\r?\\n([\\s\\S]*?)\\r?\\n```"
          ],
          "actions": [
            {
              "unsafe": true,
              "runCode": {
                "language": "$1",
                "code": "$2"
              }
            }
          ]
        }
      ]
    }
  ]
}
````

#### DITA patterns

:::info

**Beta**: DITA markup patterns are available in beta and subject to change.

:::

Doc Detective extracts tests from DITA task topics using semantic markup. It recognizes DITA elements like `<uicontrol>`, `<userinput>`, `<systemoutput>`, `<shortcut>`, and `<cmdname>` within `<cmd>` elements and automatically generates tests from properly structured DITA content.

````json
{
  "fileTypes": [
    {
      "name": "dita",
      "extensions": ["dita", "ditamap", "xml"],
      "markup": [
        {
          "name": "clickUiControl",
          "regex": [
            "<cmd>\\s*(?:[Cc]lick|[Tt]ap|[Ss]elect|[Pp]ress|[Cc]hoose)\\s+(?:the\\s+)?<uicontrol>([^<]+)<\\/uicontrol>"
          ],
          "actions": ["click"]
        },
        {
          "name": "typeIntoUiControl",
          "regex": [
            "<cmd>\\s*(?:[Tt]ype|[Ee]nter|[Ii]nput)\\s+<userinput>([^<]+)<\\/userinput>\\s+(?:in|into)(?:\\s+the)?\\s+<uicontrol>([^<]+)<\\/uicontrol>"
          ],
          "actions": [
            {
              "type": {
                "keys": "$1",
                "selector": "$2"
              }
            }
          ]
        },
        {
          "name": "navigateToXref",
          "regex": [
            "<cmd>\\s*(?:[Nn]avigate\\s+to|[Oo]pen|[Gg]o\\s+to|[Vv]isit|[Bb]rowse\\s+to)\\s+<xref\\s+[^>]*href=\"(https?:\\/\\/[^\"]+)\"[^>]*>"
          ],
          "actions": ["goTo"]
        },
        {
          "name": "runShellCmdWithCodeblock",
          "regex": [
            "<cmd>\\s*(?:[Rr]un|[Ee]xecute)\\s+(?:the\\s+)?(?:following\\s+)?(?:command)[^<]*<\\/cmd>\\s*<info>\\s*<codeblock[^>]*outputclass=\"(?:shell|bash)\"[^>]*>([\\s\\S]*?)<\\/codeblock>"
          ],
          "actions": [
            {
              "runShell": {
                "command": "$1"
              }
            }
          ]
        },
        {
          "name": "verifySystemOutput",
          "regex": [
            "<cmd>\\s*(?:[Vv]erify|[Cc]heck|[Cc]onfirm|[Ee]nsure)\\s+[^<]*<systemoutput>([^<]+)<\\/systemoutput>"
          ],
          "actions": ["find"]
        },
        {
          "name": "findUiControl",
          "regex": [
            "<uicontrol>([^<]+)<\\/uicontrol>"
          ],
          "actions": ["find"]
        },
        {
          "name": "verifyWindowTitle",
          "regex": [
            "<wintitle>([^<]+)<\\/wintitle>"
          ],
          "actions": ["find"]
        },
        {
          "name": "keyboardShortcut",
          "regex": [
            "<cmd>\\s*(?:[Pp]ress)\\s+<shortcut>Enter<\\/shortcut>"
          ],
          "actions": [
            {
              "type": {
                "keys": "Enter"
              }
            }
          ]
        },
        {
          "name": "executeCmdName",
          "regex": [
            "<cmd>\\s*(?:[Ee]xecute|[Rr]un)\\s+<cmdname>([^<]+)<\\/cmdname>"
          ],
          "actions": [
            {
              "runShell": {
                "command": "$1"
              }
            }
          ]
        },
        {
          "name": "checkExternalXref",
          "regex": [
            "<xref\\s+[^>]*scope=\"external\"[^>]*href=\"(https?:\\/\\/[^\"]+)\"[^>]*>",
            "<xref\\s+[^>]*href=\"(https?:\\/\\/[^\"]+)\"[^>]*scope=\"external\"[^>]*>"
          ],
          "actions": ["checkLink"]
        },
        {
          "name": "checkHyperlink",
          "regex": [
            "<xref\\s+href=\"(https?:\\/\\/[^\"]+)\"[^>]*>"
          ],
          "actions": ["checkLink"]
        },
        {
          "name": "checkLinkElement",
          "regex": [
            "<link\\s+href=\"(https?:\\/\\/[^\"]+)\"[^>]*>"
          ],
          "actions": ["checkLink"]
        },
        {
          "name": "runShellCodeblock",
          "regex": [
            "<codeblock[^>]*outputclass=\"(?:shell|bash)\"[^>]*>([\\s\\S]*?)<\\/codeblock>"
          ],
          "actions": [
            {
              "runShell": {
                "command": "$1"
              }
            }
          ]
        },
        {
          "name": "runCode",
          "regex": [
            "<codeblock[^>]*outputclass=\"(python|py|javascript|js)\"[^>]*>([\\s\\S]*?)<\\/codeblock>"
          ],
          "actions": [
            {
              "unsafe": true,
              "runCode": {
                "language": "$1",
                "code": "$2"
              }
            }
          ]
        },
        {
          "name": "httpRequestFormat",
          "regex": [
            "<codeblock[^>]*outputclass=\"http\"[^>]*>\\s*([A-Z]+)\\s+([^\\s]+)(?:\\s+HTTP\\/[\\d.]+)?\\s*(?:\\r?\\n|&#xA;)((?:[^\\s<]+:\\s+[^\\r\\n<]+(?:\\r?\\n|&#xA;))*)(?:\\s*(?:\\r?\\n|&#xA;)([\\s\\S]*?))?\\s*<\\/codeblock>"
          ],
          "actions": [
            {
              "httpRequest": {
                "method": "$1",
                "url": "$2",
                "request": {
                  "headers": "$3",
                  "body": "$4"
                }
              }
            }
          ]
        },
        {
          "name": "clickOnscreenText",
          "regex": [
            "\\b(?:[Cc]lick|[Tt]ap|[Ll]eft-click|[Cc]hoose|[Ss]elect|[Cc]heck)\\b\\s+<b>((?:(?!<\\/b>).)+)<\\/b>"
          ],
          "actions": ["click"]
        },
        {
          "name": "findOnscreenText",
          "regex": ["<b>((?:(?!<\\/b>).)+)<\\/b>"],
          "actions": ["find"]
        },
        {
          "name": "goToUrl",
          "regex": [
            "\\b(?:[Gg]o\\s+to|[Oo]pen|[Nn]avigate\\s+to|[Vv]isit|[Aa]ccess|[Pp]roceed\\s+to|[Ll]aunch)\\b\\s+<xref\\s+href=\"(https?:\\/\\/[^\"]+)\"[^>]*>"
          ],
          "actions": ["goTo"]
        },
        {
          "name": "screenshotImage",
          "regex": [
            "<image\\s+[^>]*href=\"([^\"]+)\"[^>]*outputclass=\"[^\"]*screenshot[^\"]*\"[^>]*\\/>"
          ],
          "actions": ["screenshot"]
        },
        {
          "name": "typeText",
          "regex": ["\\b(?:[Pp]ress|[Ee]nter|[Tt]ype)\\b\\s+\"([^\"]+)\""],
          "actions": ["type"]
        }
      ]
    }
  ]
}
````

##### DITA semantic elements

DITA task topics use semantic elements to structure procedural documentation. Doc Detective recognizes these elements and extracts the appropriate test actions:

**UI Elements:**
- `<uicontrol>` - UI controls like buttons, fields, menus, and options
- `<wintitle>` - Window or dialog titles
- `<menucascade>` - Menu sequences (like File > Save As)

**User Input:**
- `<userinput>` - Text that users should type
- `<shortcut>` - Keyboard keys (like Enter)

**System Output:**
- `<systemoutput>` - Expected output from commands or system responses
- `<msgph>` - Message text from the application

**Command Execution:**
- `<cmdname>` - Command names to execute
- `<codeblock>` - Code blocks with `outputclass` for language specification

**Navigation:**
- `<xref>` - Cross-references and external links

##### DITA action verb patterns

Doc Detective recognizes specific action verbs in `<cmd>` elements to determine which test action to generate:

**Click actions** - Triggers `click`:
- click, tap, select, press, choose

**Type actions** - Triggers `type`:
- type, enter, input

**Navigation actions** - Triggers `goTo`:
- navigate to, open, go to, visit, browse to

**Verification actions** - Triggers `find`:
- verify, check, confirm, ensure

**Command execution** - Triggers `runShell`:
- run, execute

When these verbs appear with DITA semantic elements, Doc Detective automatically extracts the complete action. For example, `<cmd>Click the <uicontrol>Save</uicontrol> button</cmd>` generates `{ "click": "Save" }`.

#### Default markup pattern descriptions

##### Markdown patterns

**checkHyperlink**: Detects standard Markdown links (excluding images) and checks that they return a valid HTTP status code.

- Pattern: `[link text](https://example.com)`
- Action: Performs a GET request to verify the link is accessible

**clickOnscreenText**: Detects action verbs followed by bold text and clicks on that element.

- Pattern: `Click **Button Name**`, `Tap **Menu Item**`, `Select **Option**`
- Action: Clicks on the specified element using its text content

**findOnscreenText**: Detects any bold text and verifies it exists on the page.

- Pattern: `**Any Bold Text**`
- Action: Searches for the text on the current page

**goToUrl**: Detects navigation instructions with links and opens the URL.

- Pattern: `Go to [Page Name](https://example.com)`, `Navigate to [Site](https://example.com)`
- Action: Opens the specified URL in the browser

**screenshotImage**: Detects images with a `.screenshot` class or attribute and takes a screenshot.

- Pattern: `![Alt text](image.png){.screenshot}`
- Action: Saves a screenshot to the specified path

**typeText**: Detects typing instructions with quoted text and types the content.

- Pattern: `Type "Hello World"`, `Enter "username"`
- Action: Types the specified text into the active element

**httpRequestFormat**: Detects HTTP request code blocks and executes the request.

- Pattern: HTTP request in code blocks with method, URL, headers, and body
- Action: Executes the HTTP request with the specified parameters

**runCode**: Detects code blocks in supported languages and executes the code.

- Pattern: Code blocks with `bash`, `python`, `py`, `javascript`, or `js` language tags (excluding those marked with `testIgnore`)
- Action: Executes the code in the specified language (marked as unsafe)

##### DITA patterns

**clickUiControl**: Detects click verbs with `<uicontrol>` elements in DITA `<cmd>` elements and clicks on that UI control.

- Pattern: `<cmd>Click the <uicontrol>Submit</uicontrol> button</cmd>`
- Action: Clicks the "Submit" button using its text content
- Recognized verbs: click, tap, select, press, choose

**typeIntoUiControl**: Detects type verbs with `<userinput>` and `<uicontrol>` elements and types text into the specified field.

- Pattern: `<cmd>Type <userinput>testuser</userinput> into the <uicontrol>Username</uicontrol> field</cmd>`
- Action: Types "testuser" into the field labeled "Username"
- Recognized verbs: type, enter, input

**navigateToXref**: Detects navigation verbs with `<xref>` elements in `<cmd>` elements and opens the URL.

- Pattern: `<cmd>Navigate to <xref href="https://example.com">Example Site</xref></cmd>`
- Action: Opens https://example.com in the browser
- Recognized verbs: navigate to, open, go to, visit, browse to

**runShellCmdWithCodeblock**: Detects run/execute commands followed by shell codeblocks in `<info>` elements.

- Pattern: `<cmd>Run the following command</cmd>` followed by `<info><codeblock outputclass="shell">npm install</codeblock></info>`
- Action: Executes "npm install" as a shell command
- Recognized verbs: run, execute

**verifySystemOutput**: Detects verification verbs with `<systemoutput>` elements and checks for expected output.

- Pattern: `<cmd>Verify the output shows <systemoutput>Success</systemoutput></cmd>`
- Action: Searches for "Success" on the current page
- Recognized verbs: verify, check, confirm, ensure

**findUiControl**: Detects standalone `<uicontrol>` elements and verifies they exist on the page.

- Pattern: `<uicontrol>Save Button</uicontrol>`
- Action: Searches for "Save Button" on the current page

**verifyWindowTitle**: Detects `<wintitle>` elements and verifies the window or dialog title exists.

- Pattern: `<wintitle>Settings Dialog</wintitle>`
- Action: Searches for "Settings Dialog" on the current page

**executeCmdName**: Detects execute/run verbs with `<cmdname>` elements and runs the command.

- Pattern: `<cmd>Execute <cmdname>npm test</cmdname></cmd>`
- Action: Executes "npm test" as a shell command
- Recognized verbs: run, execute

**checkExternalXref**: Detects `<xref>` elements with `scope="external"` and checks link accessibility.

- Pattern: `<xref href="https://docs.example.com" scope="external">Documentation</xref>`
- Action: Performs a GET request to verify the link returns a valid status code

**checkHyperlink**: Detects DITA xref elements with HTTP/HTTPS URLs and checks that they return a valid HTTP status code.

- Pattern: `<xref href="https://example.com">Link</xref>`
- Action: Performs a GET request to verify the link is accessible

**checkLinkElement**: Detects `<link>` elements and checks they return a valid status code.

- Pattern: `<link href="https://example.com">Example</link>`
- Action: Performs a GET request to verify the link is accessible

**runShellCodeblock**: Detects standalone shell/bash codeblocks and executes them.

- Pattern: `<codeblock outputclass="bash">echo "Hello"</codeblock>`
- Action: Executes the shell command

**runCode**: Detects code blocks in supported languages (Python, JavaScript) and executes them.

- Pattern: `<codeblock outputclass="python">print("Hello")</codeblock>`
- Action: Executes the code (marked as unsafe)

**httpRequestFormat**: Detects HTTP request codeblocks and executes the request.

- Pattern: `<codeblock outputclass="http">GET /api/users HTTP/1.1</codeblock>` with method, URL, headers, and optional body
- Action: Executes the HTTP request with the specified parameters

**clickOnscreenText**: Detects action verbs followed by bold text (legacy pattern for backwards compatibility).

- Pattern: `Click <b>Button Name</b>`
- Action: Clicks on the specified element using its text content

**findOnscreenText**: Detects bold text (legacy pattern for backwards compatibility).

- Pattern: `<b>Any Bold Text</b>`
- Action: Searches for the text on the current page

**goToUrl**: Detects navigation instructions with xref elements (legacy pattern for backwards compatibility).

- Pattern: `Go to <xref href="https://example.com">Page</xref>`
- Action: Opens the specified URL in the browser

**screenshotImage**: Detects image elements with a screenshot outputclass and takes a screenshot.

- Pattern: `<image href="image.png" outputclass="screenshot"/>`
- Action: Saves a screenshot to the specified path

**typeText**: Detects typing instructions with quoted text (legacy pattern for backwards compatibility).

- Pattern: `Type "Hello World"`
- Action: Types the specified text into the active element

The `regex` property defines the regular expression patterns to match, and the `actions` property defines the actions to perform when the pattern is detected. With the default configuration, Doc Detective would take the following Markdown and generate tests automatically:

Markdown:

```markdown
To get started,

1. Go to [Acme Console](https://console.acme.com).
2. Click **Search**.
3. Type "American Shorthair kittens".

Check out our [documentation](https://docs.example.com) for more information.

![Search results](search-results.png){ .screenshot }
```

Detected tests:

```json
{
  "tests": [
    {
      "steps": [
        {
          "goTo": "https://console.acme.com"
        },
        {
          "click": "Search"
        },
        {
          "type": "American Shorthair kittens"
        },
        {
          "checkLink": "https://docs.example.com"
        },
        {
          "screenshot": "search-results.png"
        }
      ]
    }
  ]
}
```

**DITA example with detected tests:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="getting-started">
  <title>Getting Started</title>
  <!-- test testId="dita-detected-test" detectSteps=true -->
  <body>
    <p>To get started,</p>
    <ol>
      <li>Go to <xref href="https://console.acme.com">Acme Console</xref>.</li>
      <li>Click <b>Search</b>.</li>
      <li>Type "American Shorthair kittens".</li>
    </ol>
    <p>Check out our <xref href="https://docs.example.com">documentation</xref> for more information.</p>
    <fig>
      <image href="search-results.png" outputclass="screenshot"/>
    </fig>
  </body>
  <!-- test end -->
</topic>
```

Detected tests:

```json
{
  "tests": [
    {
      "steps": [
        {
          "goTo": "https://console.acme.com"
        },
        {
          "click": "Search"
        },
        {
          "type": "American Shorthair kittens"
        },
        {
          "checkLink": "https://docs.example.com"
        },
        {
          "screenshot": "search-results.png"
        }
      ]
    }
  ]
}
```

**DITA task topic example with semantic elements:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE task PUBLIC "-//OASIS//DTD DITA Task//EN" "task.dtd">
<task id="create-user-account">
  <title>Create a User Account</title>
  <!-- test testId="user-account-test" detectSteps=true -->
  <taskbody>
    <context>
      <p>This procedure shows how to create a new user account in the system.</p>
    </context>
    <steps>
      <step>
        <cmd>Navigate to <xref href="https://app.example.com/login" format="html" scope="external">the application</xref></cmd>
      </step>
      <step>
        <cmd>Click the <uicontrol>Sign In</uicontrol> button</cmd>
      </step>
      <step>
        <cmd>Type <userinput>admin@example.com</userinput> into the <uicontrol>Username</uicontrol> field</cmd>
      </step>
      <step>
        <cmd>Type <userinput>password123</userinput> into the <uicontrol>Password</uicontrol> field</cmd>
      </step>
      <step>
        <cmd>Press <shortcut>Enter</shortcut> to submit the form</cmd>
      </step>
      <step>
        <cmd>Click the <uicontrol>New User</uicontrol> button</cmd>
      </step>
      <step>
        <cmd>Verify the <wintitle>Create User</wintitle> dialog appears</cmd>
      </step>
      <step>
        <cmd>Execute <cmdname>npm test</cmdname> to run validation checks</cmd>
      </step>
      <step>
        <cmd>Run the following command</cmd>
        <info>
          <codeblock outputclass="shell">curl -X POST https://api.example.com/users</codeblock>
        </info>
      </step>
      <step>
        <cmd>Verify the output shows <systemoutput>User created successfully</systemoutput></cmd>
      </step>
    </steps>
    <result>
      <p>The new user account is created and ready to use.</p>
    </result>
  </taskbody>
  <!-- test end -->
</task>
```

Detected tests:

```json
{
  "tests": [
    {
      "steps": [
        {
          "goTo": "https://app.example.com/login"
        },
        {
          "click": "Sign In"
        },
        {
          "type": {
            "keys": "admin@example.com",
            "selector": "Username"
          }
        },
        {
          "type": {
            "keys": "password123",
            "selector": "Password"
          }
        },
        {
          "type": {
            "keys": "Enter"
          }
        },
        {
          "click": "New User"
        },
        {
          "find": "Create User"
        },
        {
          "runShell": {
            "command": "npm test"
          }
        },
        {
          "runShell": {
            "command": "curl -X POST https://api.example.com/users"
          }
        },
        {
          "find": "User created successfully"
        }
      ]
    }
  ]
}
```

### Custom markup patterns

You can extend or override the default patterns by defining custom markup patterns in your configuration:

```json
{
  "fileTypes": [
    {
      "name": "markdown",
      "extensions": ["md", "markdown", "mdx"],
      "markup": [
        {
          "name": "customAction",
          "regex": ["\\b(?:custom)\\b\\s+\\*\\*(.+?)\\*\\*"],
          "actions": [
            {
              "find": {
                "selector": "aria/$1",
                "timeout": 10000
              }
            }
          ]
        }
      ]
    }
  ]
}
```

#### Other file types

Doc Detective also includes default configurations for HTML and AsciiDoc files. These currently only include inline statement patterns for test definitions and don't include markup patterns for detected tests:

**HTML files** (`.html`, `.htm`):

- Uses HTML comment syntax for inline test statements
- Example: `<!-- test { "testId": "my-test" } -->`

**AsciiDoc files** (`.adoc`, `.asciidoc`, `.asc`):

- Uses AsciiDoc comment syntax for inline test statements
- Example: `// (test { "testId": "my-test" })`

**DITA files** (`.dita`, `.ditamap`, `.xml`):

DITA includes both inline statement patterns (processing instructions and HTML comments) and markup patterns for detected tests. See the [DITA inline statements](#inline-json-or-yaml) and [default markup patterns](#detected-tests) sections above for complete documentation.

To add detected test functionality to HTML or AsciiDoc files, you would need to define custom markup patterns in your configuration similar to the Markdown examples above.

### Default actions

If you only need to perform basic steps, you can define actions using a shorthand of only specifying the action name. Doc Detective uses default actions, substituting the first capture group (or if there are no capture groups, the entire match) from the regex pattern into the most common location for the action. In the above example, the config generates a `goTo` action for every Markdown hyperlink preceded by a navigation verb.

The default actions are as follows:

#### `checkLink`

Check that the match returns a valid status code.

```json
{ "checkLink": "$1" }
```

### `click`

Click or tap the match.

```json
{ "click": "$1" }
```

#### `goTo`

Open the match as a URL in a browser.

```json
{ "goTo": "$1" }
```

#### `find`

Find an element on the current page that has an ARIA label that equals the match.

```json
{ "find": "$1" }
```

#### `screenshot`

Save a screenshot to a path equalling the match.

```json
{ "screenshot": "$1" }
```

#### `type`

Type the match into the current page.

```json
{ "type": "$1" }
```

#### `httpRequest`

Make an GET request to the match.

```json
{ "httpRequest": "$1" }
```

#### `runShell`

Run the match as a shell command.

```json
{ "runShell": "$1" }
```

#### `record`

Start recording a video to a path equalling the match.

```json
{ "record": "$1" }
```

#### `stopRecord`

Stop recording a video.

```json
{ "stopRecord": true }
```

#### `wait`

Wait for the specified duration.

```json
{ "wait": "$1" }
```

#### `loadVariables`

Load environment variables from an `.env` file, where the path is the match.

```json
{ "loadVariables": "$1" }
```

#### `saveCookie`

Save a browser cookie by name to a default location.

```json
{ "saveCookie": "$1" }
```

#### `loadCookie`

Load a browser cookie by name from a default location.

```json
{ "loadCookie": "$1" }
```

## Run tests

Doc Detective's `doc-detective` command runs your tests. Input files are read from your config's `input` property, but you can also specify input files directly in the command with the `--input` flag.

This example runs all test specs in your config's `input` and `runTest.input` parameters:

<Tabs>
  <TabItem value="npx" label="NPX" default>

```bash
npx doc-detective
```

  </TabItem>
  <TabItem value="docker" label="Docker">

```bash
docker run -v .:/app docdetective/docdetective
```

:::note
The `-v` argument mounts your current directory (`.`) to `/app` in the container, giving Doc Detective access to your test specifications.
:::

  </TabItem>
</Tabs>

This example runs all test specs in a file named `doc-content.md` in the `samples` directory:

<Tabs>
  <TabItem value="npx" label="NPX" default>

```bash
npx doc-detective --input ./samples/doc-content.md
```

  </TabItem>
  <TabItem value="docker" label="Docker">

```bash
docker run -v .:/app docdetective/docdetective --input /app/samples/doc-content.md
```

  </TabItem>
</Tabs>

### Remotely hosted tests

You can run tests hosted remotely by specifying the URL of the test file with the `--input` argument. For example, to run tests from a file hosted at `https://doc-detective.com/sample.spec.json`, run the following command:

<Tabs>
  <TabItem value="npx" label="NPX" default>

```bash
npx doc-detective --input https://doc-detective.com/sample.spec.json
```

  </TabItem>
  <TabItem value="docker" label="Docker">

```bash
docker run docdetective/docdetective --input https://doc-detective.com/sample.spec.json
```

:::note
The `-v` argument is not necessary for remotely hosted tests since Docker doesn't need access to local files.
:::

  </TabItem>
</Tabs>

These tests run the same way as local tests, but Doc Detective fetches the test file from the specified URL and stores it in a temporary directory. The URL must be accessible to the machine running the tests.

### Run tests with multiple files

You can run tests using multiple files in multiple directories. Add as many comma-separated input values as necessary.

<Tabs>
  <TabItem value="npx" label="NPX" default>

```bash
npx doc-detective --input inline-tests.md,https://doc-detective.com/sample.spec.json,./samples/doc-content.md
```

  </TabItem>
  <TabItem value="docker" label="Docker">

```bash
docker run -v .:/app docdetective/docdetective --input /app/inline-tests.md,https://doc-detective.com/sample.spec.json,/app/samples/doc-content.md
```

  </TabItem>
</Tabs>

## Read the results

Doc Detective outputs test results to a `testResults-<timestamp>.json` file in your `output` directory. You can also specify your output directory with the `--output` flag:

<Tabs>
  <TabItem value="npx" label="NPX" default>

```bash
npx doc-detective --input ./samples/doc-content.md --output ./samples/
```

  </TabItem>
  <TabItem value="docker" label="Docker">

```bash
docker run -v .:/app docdetective/docdetective --input /app/samples/doc-content.md --output /app/samples/
```

  </TabItem>
</Tabs>
